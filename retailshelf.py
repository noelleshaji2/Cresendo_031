# -*- coding: utf-8 -*-
"""RetailShelf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f9cG6GKOuevVNY-jCU0BR63GMAPE3OxD
"""

#Profit margin optimization

pip install pulp


from pulp import LpMaximize, LpProblem, LpVariable
import pandas as pd

# Load the dataset
data = pd.read_csv('product_dataset.csv')

# Extract relevant information from the dataset
products = {}
for index, row in data.iterrows():
    products[row['Product_ID']] = {'margin': row['Profit_Margin'], 'shelf_space': row['Shelf_Space']}

# Define the problem as a maximization problem
prob = LpProblem("Profit_Margin_Optimization", LpMaximize)

# Decision variables: Binary variables indicating whether to allocate shelf space to each product
product_vars = LpVariable.dicts("Product", products.keys(), lowBound=0, upBound=1, cat='Binary')

# Objective function: Maximize total profit margin
prob += sum(products[prod]['margin'] * product_vars[prod] for prod in products)

# Constraint: Total shelf space cannot exceed a certain limit (e.g., 2 units)
prob += sum(products[prod]['shelf_space'] * product_vars[prod] for prod in products) <= 2

# Solve the problem
prob.solve()

# Print the results
print("Status:", LpProblem.status[prob.status])
print("Optimal Solution:")
for v in prob.variables():
    if v.varValue == 1:
        print(f"{v.name} = {v.varValue}")

print("Total Profit Margin:", round(sum(products[prod]['margin'] * v.varValue for prod, v in product_vars.items() if v.varValue == 1), 2))



"""# New Section"""

from pulp import *

import pandas as pd

# Step 1: Read products data from CSV file
products_df = pd.read_csv(r'products.csv')

# Step 2: Calculate popularity score based on historical sales data or customer reviews
# For example, you can calculate popularity score based on monthly demand
products_df['popularity_score'] = products_df['monthly_demand']

# Step 3: Incorporate seasonal variation analysis
# For example, you can identify seasonal trends using replenishment_interval
# and adjust the popularity score accordingly
products_df['popularity_score'] *= (12 / products_df['replinishment_interval'])

# Step 4: Calculate profit margin for each product
products_df['profit_margin'] = products_df['price'] * products_df['unit_margin']

# Step 5: Implement profit margin optimization by prioritizing products with higher profit margins
# and popularity scores
products_df['shelf_space_allocation_score'] = products_df['popularity_score'] * products_df['profit_margin']

# Sort products by shelf space allocation score in descending order
products_df = products_df.sort_values(by='shelf_space_allocation_score', ascending=False)

# Allocate shelf space based on the sorted order
# You can define your own allocation strategy based on available shelf space and other constraints

# Display the products with shelf space allocation scores
print(products_df[['product_id', 'shelf_space_allocation_score']])

from google.colab import files
uploaded = files.upload()



import pandas as pd

# Step 1: Read products data from CSV file
products_df = pd.read_csv(r'products.csv')

# Step 2: Calculate popularity score based on historical sales data or customer reviews
# For example, you can calculate popularity score based on monthly demand
products_df['popularity_score'] = products_df['monthly_demand']

# Step 3: Incorporate seasonal variation analysis
# For example, you can identify seasonal trends using replenishment_interval
# and adjust the popularity score accordingly
products_df['popularity_score'] *= (12 / products_df['replinishment_interval'])

# Step 4: Calculate profit margin for each product
products_df['profit_margin'] = products_df['price'] * products_df['unit_margin']

# Step 5: Implement profit margin optimization by prioritizing products with higher profit margins
# and popularity scores
products_df['shelf_space_allocation_score'] = products_df['popularity_score'] * products_df['profit_margin']

# Sort products by shelf space allocation score in descending order
products_df = products_df.sort_values(by='shelf_space_allocation_score', ascending=False)

# Allocate shelf space based on the sorted order
# You can define your own allocation strategy based on available shelf space and other constraints

# Display the products with shelf space allocation scores
print(products_df[['product_id', 'shelf_space_allocation_score']])

import pandas as pd
import numpy as np
import statsmodels.api as sm

# Load your dataset
# Replace 'dataset.csv' with the actual path to your dataset
data = pd.read_csv('/content/product_data - product_data.csv.csv')

# Assuming the first column contains product names, set it as the index
data.set_index(data.columns[0], inplace=True)

# Create a DataFrame to store seasonal variations for each product
seasonal_variation_per_product = pd.DataFrame(index=data.index)

# Loop through each product and calculate seasonal variation
for product in data.index:
    product_data = data.loc[[product]].transpose()

    # Decompose time series to get the seasonal component
    seasonal_decomposition = sm.tsa.seasonal_decompose(product_data, period=12)

    # Extract the seasonal component (seasonal variation) for the current product
    seasonal_variation_per_product[product + '_seasonal_variation'] = seasonal_decomposition.seasonal.transpose()[product]

# Append the seasonal variations as new columns to the original dataset
data_with_seasonal_variations = pd.concat([data, seasonal_variation_per_product], axis=1)

# Save the result to a new CSV file or use it as needed
data_with_seasonal_variations.to_csv('dataset_with_seasonal_variations.csv')

# Print the dataset with seasonal variations
print("Dataset with Seasonal Variations:")
print(data_with_seasonal_variations)

#NEW
import pandas as pd

def calculate_profit_margin(products_list, csv_file):
    # Read the CSV file
    df = pd.read_csv(csv_file)

    # Filter DataFrame based on products_list
    filtered_df = df[df['Product Name'].isin(products_list)]

    if filtered_df.empty:
        print("No products found in the list.")
        return None

    # Calculate total revenue for each month
    for month in range(1, 13):
        df[f'Total_Revenue_{month}'] = df[f'Selling Price ({month})'] * df[f'Units Sold ({month})']

    # Calculate total revenue for all months
    total_revenue_cols = [f'Total_Revenue_{month}' for month in range(1, 13)]
    df['Total_Revenue'] = df[total_revenue_cols].sum(axis=1)

    # Calculate profit margin
    df['Profit_Margin'] = (df['Total_Profit'] / df['Total_Revenue'])

    # Extract profit margin for specified products
    result_df = df[df['Product Name'].isin(products_list)][['Product Name', 'Profit_Margin']]

    return result_df

products_list = ['Mascara', 'Ball', 'Bronzer']
csv_file = 'Final_data - product_data.csv (1).csv'

result_df = calculate_profit_margin(products_list, csv_file)
print(result_df)

import pandas as pd

# Assuming the dataset is stored in a CSV file named 'product_data.csv'
# Adjust the file path accordingly if it's in a different format or location
dataset_path = 'Final_data - product_data.csv (1).csv'

def calculate_sell_through_rate_and_score_for_product_list(product_names):
    results = {}
    dataset = pd.read_csv(dataset_path)

    for product_name in product_names:
        product_data = dataset[dataset['Product Name'] == product_name]
        if len(product_data) == 0:
            print(f"Product '{product_name}' not found in the dataset.")
            continue

        total_units_sold = product_data.filter(like='Units Sold').sum().sum()
        total_units_bought = product_data.filter(like='Units Bought').sum().sum()
        sell_through_rate = total_units_sold / total_units_bought if total_units_bought > 0 else 0

        average_rating = product_data['Average_rating'].values[0]

        # Scale the sell_through_rate to the range [0, 1]
        scaled_sell_through_rate = sell_through_rate

        # Scale the average_rating to the range [0, 1]
        scaled_average_rating = (average_rating - 1) / (5 - 1)  # Min-max scaling

        # Calculate the score using the scaled values
        score = (scaled_sell_through_rate + scaled_average_rating) / 2

        results[product_name] = {'Sell Through Rate': sell_through_rate, 'Score': score}

    return results

# Example usage:
product_names = ['Mascara', 'Ball', 'Bronzer']  # Replace with the list of product names you want to analyze
results = calculate_sell_through_rate_and_score_for_product_list(product_names)
for product_name, result in results.items():
    print(f"Product: {product_name}")
    print(f"Sell Through Rate: {result['Sell Through Rate']}")
    print(f"Score: {result['Score']}")
    print()

x_size = int(input('Enter number of shelves: '))
y_size = int(input('Enter number of rows in each shelf: '))
z_size = int(input('Enter number of columns in each shelf: '))
D = list(input('Rank all rows on the basis of customer reach: '))

matrix_3d = [[[0 for _ in range(y_size)] for _ in range(z_size)] for _ in range(x_size)]
D = [int(x) for x in D]

total_pos = x_size * y_size * z_size
row_size = y_size * z_size

shelf_positions = []
total_positions_allocated = 0
#weights = [0.82, 0.56, 0.34]
weights=results
#print(type(weights))
# Calculate the number of positions allocated for each product
for weight in weights:
    allocated_pos = round((round((weight / sum(weights)), 2) * total_pos))
    shelf_positions.append(allocated_pos)

# Sort products based on the number of positions allocated
sorted_products = sorted(enumerate(shelf_positions), key=lambda x: x[1], reverse=True)

# Place products in the 3D matrix
for product_id, _ in sorted_products:
    quantity_to_place = shelf_positions[product_id]

    for shelf_index in range(x_size):
        for row_index in range(z_size):
            for col_index in range(y_size):
                if matrix_3d[shelf_index][row_index][col_index] == 0:
                    matrix_3d[shelf_index][row_index][col_index] = product_id + 1
                    quantity_to_place -= 1
                    total_positions_allocated += 1

                    if quantity_to_place == 0 or total_positions_allocated == total_pos:
                        break
            if quantity_to_place == 0 or total_positions_allocated == total_pos:
                break
        if quantity_to_place == 0 or total_positions_allocated == total_pos:
            break

# Print the result for demonstration
#for shelf_index in range(x_size):
#    print(f"Shelf {shelf_index + 1}:")
#    for row_index in range(z_size):
#        print(matrix_3d[shelf_index][row_index])
#    print()
#print(shelf_positions)


transposed_matrix_3d = [
    [
        [matrix_3d[shelf][row][col] for row in range(len(matrix_3d[shelf]))]
        for col in range(len(matrix_3d[shelf][0]))
    ]
    for shelf in range(len(matrix_3d))
]

print("\nTransposed Matrix:")
for shelf_index in range(x_size):
    print(f"Shelf {shelf_index + 1}:")
    for row_index in range(y_size):
        print(transposed_matrix_3d[shelf_index][row_index])
    print()

import pandas as pd

# Assuming the dataset is stored in a CSV file named 'product_data.csv'
# Adjust the file path accordingly if it's in a different format or location
dataset_path = 'Final_data - product_data.csv (1).csv'

def calculate_sell_through_rate_and_score_for_product_list(product_names):
    scores = []
    dataset = pd.read_csv(dataset_path)

    for product_name in product_names:
        product_data = dataset[dataset['Product Name'] == product_name]
        if len(product_data) == 0:
            print(f"Product '{product_name}' not found in the dataset.")
            continue

        total_units_sold = product_data.filter(like='Units Sold').sum().sum()
        total_units_bought = product_data.filter(like='Units Bought').sum().sum()
        sell_through_rate = total_units_sold / total_units_bought if total_units_bought > 0 else 0

        average_rating = product_data['Average_rating'].values[0]

        # Scale the sell_through_rate to the range [0, 1]
        scaled_sell_through_rate = sell_through_rate

        # Scale the average_rating to the range [0, 1]
        scaled_average_rating = (average_rating - 1) / (5 - 1)  # Min-max scaling

        # Calculate the score using the scaled values
        score = (scaled_sell_through_rate + scaled_average_rating) / 2

        scores.append(score)

    return scores

# Example usage:
product_names = ['Mascara', 'Ball', 'Bronzer']  # Replace with the list of product names you want to analyze
scores = calculate_sell_through_rate_and_score_for_product_list(product_names)
print("Scores:", scores)



import pandas as pd

def calculate_profit_margin(products_list, csv_file):
    # Read the CSV file
    df = pd.read_csv(csv_file)

    # Filter DataFrame based on products_list
    filtered_df = df[df['Product Name'].isin(products_list)]

    if filtered_df.empty:
        print("No products found in the list.")
        return None

    # Calculate total revenue for each month
    for month in range(1, 13):
        df[f'Total_Revenue_{month}'] = df[f'Selling Price ({month})'] * df[f'Units Sold ({month})']

    # Calculate total revenue for all months
    total_revenue_cols = [f'Total_Revenue_{month}' for month in range(1, 13)]
    df['Total_Revenue'] = df[total_revenue_cols].sum(axis=1)

    # Calculate profit margin
    df['Profit_Margin'] = (df['Total_Profit'] / df['Total_Revenue'])

    # Extract profit margin for specified products
    result_df = df[df['Product Name'].isin(products_list)][['Product Name', 'Profit_Margin']]

    # Store profit margins in a list
    profit_margins = result_df['Profit_Margin'].tolist()

    return profit_margins

products_list = ['Mascara', 'Ball', 'Bronzer']
csv_file = 'Final_data - product_data.csv (1).csv'

profit_margins = calculate_profit_margin(products_list, csv_file)
print("Profit Margins:", profit_margins)

results=[]
for i in range(len(scores)):
  results.append(scores[i]*profit_margins[i])
#result = [x * y for x, y in zip(scores, profit_margins)]

print(result)

import pandas as pd

def calculate_profit_margin(products_list, csv_file):
    # Read the CSV file
    df = pd.read_csv(csv_file)

    # Filter DataFrame based on products_list
    filtered_df = df[df['Product Name'].isin(products_list)]

    if filtered_df.empty:
        print("No products found in the list.")
        return None

    # Calculate total revenue for each month
    for month in range(1, 13):
        df[f'Total_Revenue_{month}'] = df[f'Selling Price ({month})'] * df[f'Units Sold ({month})']

    # Calculate total revenue for all months
    total_revenue_cols = [f'Total_Revenue_{month}' for month in range(1, 13)]
    df['Total_Revenue'] = df[total_revenue_cols].sum(axis=1)

    # Calculate profit margin
    df['Profit_Margin'] = (df['Total_Profit'] / df['Total_Revenue'])

    # Extract profit margin for specified products
    result_df = df[df['Product Name'].isin(products_list)][['Product Name', 'Profit_Margin']]

    # Store profit margins in a list
    profit_margins = result_df['Profit_Margin'].tolist()

    return profit_margins

products_list = ['Mascara', 'Ball', 'Bronzer']
csv_file = 'Final_data - product_data.csv (1).csv'

profit_margins = calculate_profit_margin(products_list, csv_file)
print("Profit Margins:", profit_margins)





import pandas as pd

# Assuming the dataset is stored in a CSV file named 'product_data.csv'
# Adjust the file path accordingly if it's in a different format or location
dataset_path = 'Final_data - product_data.csv (1).csv'

def calculate_sell_through_rate_and_score_for_product_list(product_names):
    scores = []
    dataset = pd.read_csv(dataset_path)

    for product_name in product_names:
        product_data = dataset[dataset['Product Name'] == product_name]
        if len(product_data) == 0:
            print(f"Product '{product_name}' not found in the dataset.")
            continue

        total_units_sold = product_data.filter(like='Units Sold').sum().sum()
        total_units_bought = product_data.filter(like='Units Bought').sum().sum()
        sell_through_rate = total_units_sold / total_units_bought if total_units_bought > 0 else 0

        average_rating = product_data['Average_rating'].values[0]

        # Scale the sell_through_rate to the range [0, 1]
        scaled_sell_through_rate = sell_through_rate

        # Scale the average_rating to the range [0, 1]
        scaled_average_rating = (average_rating - 1) / (5 - 1)  # Min-max scaling

        # Calculate the score using the scaled values
        score = (scaled_sell_through_rate + scaled_average_rating) / 2

        scores.append(score)

    return scores

# Take input from the user for product names
product_names_input = input("Enter product names (comma-separated): ")
product_names = [name.strip() for name in product_names_input.split(',')]

scores = calculate_sell_through_rate_and_score_for_product_list(product_names)
print("Scores:", scores)


import pandas as pd

def calculate_profit_margin(products_list, csv_file):
    # Read the CSV file
    df = pd.read_csv(csv_file)

    # Filter DataFrame based on products_list
    filtered_df = df[df['Product Name'].isin(products_list)]

    if filtered_df.empty:
        print("No products found in the list.")
        return None

    # Calculate total revenue for each month
    for month in range(1, 13):
        df[f'Total_Revenue_{month}'] = df[f'Selling Price ({month})'] * df[f'Units Sold ({month})']

    # Calculate total revenue for all months
    total_revenue_cols = [f'Total_Revenue_{month}' for month in range(1, 13)]
    df['Total_Revenue'] = df[total_revenue_cols].sum(axis=1)

    # Calculate profit margin
    df['Profit_Margin'] = (df['Total_Profit'] / df['Total_Revenue'])

    # Extract profit margin for specified products
    result_df = df[df['Product Name'].isin(products_list)][['Product Name', 'Profit_Margin']]

    # Store profit margins in a list
    profit_margins = result_df['Profit_Margin'].tolist()

    return profit_margins

csv_file = 'Final_data - product_data.csv (1).csv'

profit_margins = calculate_profit_margin(product_names, csv_file)
print("Profit Margins:", profit_margins)

results=[]
for i in range(len(scores)):
  results.append(scores[i]*profit_margins[i])
#result = [x * y for x, y in zip(scores, profit_margins)]

print(results)




x_size = int(input('Enter number of shelves: '))
y_size = int(input('Enter number of rows in each shelf: '))
z_size = int(input('Enter number of columns in each shelf: '))
D = list(input('Rank all rows on the basis of customer reach: '))

matrix_3d = [[[0 for _ in range(y_size)] for _ in range(z_size)] for _ in range(x_size)]
D = [int(x) for x in D]

total_pos = x_size * y_size * z_size
row_size = y_size * z_size

shelf_positions = []
total_positions_allocated = 0
#weights = [0.82, 0.56, 0.34]
weights=results
#print(type(weights))
# Calculate the number of positions allocated for each product
for weight in weights:
    allocated_pos = round((round((weight / sum(weights)), 2) * total_pos))
    shelf_positions.append(allocated_pos)

# Sort products based on the number of positions allocated
sorted_products = sorted(enumerate(shelf_positions), key=lambda x: x[1], reverse=True)

# Place products in the 3D matrix
for product_id, _ in sorted_products:
    quantity_to_place = shelf_positions[product_id]

    for shelf_index in range(x_size):
        for row_index in range(z_size):
            for col_index in range(y_size):
                if matrix_3d[shelf_index][row_index][col_index] == 0:
                    matrix_3d[shelf_index][row_index][col_index] = product_id + 1
                    quantity_to_place -= 1
                    total_positions_allocated += 1

                    if quantity_to_place == 0 or total_positions_allocated == total_pos:
                        break
            if quantity_to_place == 0 or total_positions_allocated == total_pos:
                break
        if quantity_to_place == 0 or total_positions_allocated == total_pos:
            break

# Print the result for demonstration
#for shelf_index in range(x_size):
#    print(f"Shelf {shelf_index + 1}:")
#    for row_index in range(z_size):
#        print(matrix_3d[shelf_index][row_index])
#    print()
#print(shelf_positions)


transposed_matrix_3d = [
    [
        [matrix_3d[shelf][row][col] for row in range(len(matrix_3d[shelf]))]
        for col in range(len(matrix_3d[shelf][0]))
    ]
    for shelf in range(len(matrix_3d))
]

print("\nTransposed Matrix:")
for shelf_index in range(x_size):
    print(f"Shelf {shelf_index + 1}:")
    for row_index in range(y_size):
        print(transposed_matrix_3d[shelf_index][row_index])
    print()

import matplotlib.pyplot as plt
import numpy as np

# Transposed matrix data - transposed_matrix_3d


# Convert the matrix into a numpy array for plotting
matrix_array = np.array(transposed_matrix_3d)

# Create a figure and a set of subplots
fig, axes = plt.subplots(nrows=len(transposed_matrix), ncols=len(transposed_matrix[0]), figsize=(10, 8))

# Plot each sub-matrix
for i in range(len(transposed_matrix)):
    for j in range(len(transposed_matrix[i])):
        ax = axes[i, j]

        # Reshape the 1D array into a 2D array before plotting
        img_data = np.array([matrix_array[i, j]])

        ax.imshow(img_data, cmap='viridis', interpolation='nearest')
        ax.set_title(f'Shelf {i+1} - Row {j+1}')
        ax.set_xticks([])
        ax.set_yticks([])

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Transposed matrix data
transposed_matrix = [
    [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
    [[1, 3, 3], [1, 3, 3], [3, 3, 3]],
    [[3, 2, 2], [3, 2, 2], [2, 2, 2]]
]

# Convert the matrix into a numpy array for plotting
matrix_array = np.array(transposed_matrix)

# Create a figure and a set of subplots
fig, axes = plt.subplots(nrows=len(transposed_matrix), ncols=1, figsize=(8, 6))

# Plot scatter plot for each shelf
for i in range(len(transposed_matrix)):
    ax = axes[i]

    # Flatten the data for the current shelf
    shelf_data = matrix_array[i].flatten()

    # Create x-axis ticks
    x_ticks = np.arange(len(shelf_data))

    # Plot scatter plot
    ax.scatter(x_ticks, shelf_data, color='skyblue')
    ax.set_title(f'Shelf {i+1} Scatter Plot')
    ax.set_xlabel('Row')
    ax.set_ylabel('Value')
    ax.grid(True)

plt.tight_layout()
plt.show()



